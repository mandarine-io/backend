// Code generated by mockery v2.51.1. DO NOT EDIT.

package mock

import mock "github.com/stretchr/testify/mock"

// SenderMock is an autogenerated mock type for the Sender type
type SenderMock struct {
	mock.Mock
}

type SenderMock_Expecter struct {
	mock *mock.Mock
}

func (_m *SenderMock) EXPECT() *SenderMock_Expecter {
	return &SenderMock_Expecter{mock: &_m.Mock}
}

// SendHTMLMessage provides a mock function with given fields: subject, content, from, to, attachments
func (_m *SenderMock) SendHTMLMessage(subject string, content string, from string, to string, attachments ...string) error {
	_va := make([]interface{}, len(attachments))
	for _i := range attachments {
		_va[_i] = attachments[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subject, content, from, to)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendHTMLMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, ...string) error); ok {
		r0 = rf(subject, content, from, to, attachments...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SenderMock_SendHTMLMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendHTMLMessage'
type SenderMock_SendHTMLMessage_Call struct {
	*mock.Call
}

// SendHTMLMessage is a helper method to define mock.On call
//   - subject string
//   - content string
//   - from string
//   - to string
//   - attachments ...string
func (_e *SenderMock_Expecter) SendHTMLMessage(subject interface{}, content interface{}, from interface{}, to interface{}, attachments ...interface{}) *SenderMock_SendHTMLMessage_Call {
	return &SenderMock_SendHTMLMessage_Call{Call: _e.mock.On("SendHTMLMessage",
		append([]interface{}{subject, content, from, to}, attachments...)...)}
}

func (_c *SenderMock_SendHTMLMessage_Call) Run(run func(subject string, content string, from string, to string, attachments ...string)) *SenderMock_SendHTMLMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), variadicArgs...)
	})
	return _c
}

func (_c *SenderMock_SendHTMLMessage_Call) Return(_a0 error) *SenderMock_SendHTMLMessage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SenderMock_SendHTMLMessage_Call) RunAndReturn(run func(string, string, string, string, ...string) error) *SenderMock_SendHTMLMessage_Call {
	_c.Call.Return(run)
	return _c
}

// SendHTMLMessages provides a mock function with given fields: subject, content, from, to, attachments
func (_m *SenderMock) SendHTMLMessages(subject string, content string, from string, to []string, attachments ...string) error {
	_va := make([]interface{}, len(attachments))
	for _i := range attachments {
		_va[_i] = attachments[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subject, content, from, to)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendHTMLMessages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []string, ...string) error); ok {
		r0 = rf(subject, content, from, to, attachments...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SenderMock_SendHTMLMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendHTMLMessages'
type SenderMock_SendHTMLMessages_Call struct {
	*mock.Call
}

// SendHTMLMessages is a helper method to define mock.On call
//   - subject string
//   - content string
//   - from string
//   - to []string
//   - attachments ...string
func (_e *SenderMock_Expecter) SendHTMLMessages(subject interface{}, content interface{}, from interface{}, to interface{}, attachments ...interface{}) *SenderMock_SendHTMLMessages_Call {
	return &SenderMock_SendHTMLMessages_Call{Call: _e.mock.On("SendHTMLMessages",
		append([]interface{}{subject, content, from, to}, attachments...)...)}
}

func (_c *SenderMock_SendHTMLMessages_Call) Run(run func(subject string, content string, from string, to []string, attachments ...string)) *SenderMock_SendHTMLMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(string), args[3].([]string), variadicArgs...)
	})
	return _c
}

func (_c *SenderMock_SendHTMLMessages_Call) Return(_a0 error) *SenderMock_SendHTMLMessages_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SenderMock_SendHTMLMessages_Call) RunAndReturn(run func(string, string, string, []string, ...string) error) *SenderMock_SendHTMLMessages_Call {
	_c.Call.Return(run)
	return _c
}

// SendPlainMessage provides a mock function with given fields: subject, content, from, to, attachments
func (_m *SenderMock) SendPlainMessage(subject string, content string, from string, to string, attachments ...string) error {
	_va := make([]interface{}, len(attachments))
	for _i := range attachments {
		_va[_i] = attachments[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subject, content, from, to)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendPlainMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, ...string) error); ok {
		r0 = rf(subject, content, from, to, attachments...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SenderMock_SendPlainMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendPlainMessage'
type SenderMock_SendPlainMessage_Call struct {
	*mock.Call
}

// SendPlainMessage is a helper method to define mock.On call
//   - subject string
//   - content string
//   - from string
//   - to string
//   - attachments ...string
func (_e *SenderMock_Expecter) SendPlainMessage(subject interface{}, content interface{}, from interface{}, to interface{}, attachments ...interface{}) *SenderMock_SendPlainMessage_Call {
	return &SenderMock_SendPlainMessage_Call{Call: _e.mock.On("SendPlainMessage",
		append([]interface{}{subject, content, from, to}, attachments...)...)}
}

func (_c *SenderMock_SendPlainMessage_Call) Run(run func(subject string, content string, from string, to string, attachments ...string)) *SenderMock_SendPlainMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), variadicArgs...)
	})
	return _c
}

func (_c *SenderMock_SendPlainMessage_Call) Return(_a0 error) *SenderMock_SendPlainMessage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SenderMock_SendPlainMessage_Call) RunAndReturn(run func(string, string, string, string, ...string) error) *SenderMock_SendPlainMessage_Call {
	_c.Call.Return(run)
	return _c
}

// SendPlainMessages provides a mock function with given fields: subject, content, from, to, attachments
func (_m *SenderMock) SendPlainMessages(subject string, content string, from string, to []string, attachments ...string) error {
	_va := make([]interface{}, len(attachments))
	for _i := range attachments {
		_va[_i] = attachments[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subject, content, from, to)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendPlainMessages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []string, ...string) error); ok {
		r0 = rf(subject, content, from, to, attachments...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SenderMock_SendPlainMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendPlainMessages'
type SenderMock_SendPlainMessages_Call struct {
	*mock.Call
}

// SendPlainMessages is a helper method to define mock.On call
//   - subject string
//   - content string
//   - from string
//   - to []string
//   - attachments ...string
func (_e *SenderMock_Expecter) SendPlainMessages(subject interface{}, content interface{}, from interface{}, to interface{}, attachments ...interface{}) *SenderMock_SendPlainMessages_Call {
	return &SenderMock_SendPlainMessages_Call{Call: _e.mock.On("SendPlainMessages",
		append([]interface{}{subject, content, from, to}, attachments...)...)}
}

func (_c *SenderMock_SendPlainMessages_Call) Run(run func(subject string, content string, from string, to []string, attachments ...string)) *SenderMock_SendPlainMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(string), args[3].([]string), variadicArgs...)
	})
	return _c
}

func (_c *SenderMock_SendPlainMessages_Call) Return(_a0 error) *SenderMock_SendPlainMessages_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SenderMock_SendPlainMessages_Call) RunAndReturn(run func(string, string, string, []string, ...string) error) *SenderMock_SendPlainMessages_Call {
	_c.Call.Return(run)
	return _c
}

// NewSenderMock creates a new instance of SenderMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSenderMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *SenderMock {
	mock := &SenderMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
